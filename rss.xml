<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   <title>ThaddeusJiang</title>
   <link>https://thaddeusjiang.com</link>
   <description>Freelance full-stack engineer</description><follow_challenge>
    <feedId>41718658305983488</feedId>
    <userId>41718122139849728</userId>
</follow_challenge>
   <item>
      <title>同时使用多种编程语言写代码的痛</title>
      <link>https://thaddeusjiang.com/-tong-shi-shi-yong-duo-zhong-bian-cheng-yu-yan-xie-dai-ma-de-tong</link>
			<description><![CDATA[
<div class="content">
  <p>我觉得“痛”这个词也不恰当，但是我也知道该用哪个词来形容。我考虑过“困境”、“难点”、“不爽”、“苦楚”等等，都不太恰当。</p><p>算了，我还是来形容一下场景吧。</p><p>我是一名多语言使用者，编程时同时用 JavaScript 和 Elixir，日常生活中、日、英混杂。</p><p>因为使用 JavaScript 的频率太高了，有时我会把 JavaScript 的某些特性误以为是编程语言的共同特性，例如：await 。</p><p>相信，所有合格的 JavaScript 开发者都知道下面这段代码的输出：</p><pre class="hljs"><code class="js hljs"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, <span class="hljs-string">&quot;start&quot;</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, <span class="hljs-string">&quot;middle&quot;</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, <span class="hljs-string">&quot;end&quot;</span>);
}

<span class="hljs-title function_">foo</span>(<span class="hljs-string">&quot;First&quot;</span>);
<span class="hljs-title function_">foo</span>(<span class="hljs-string">&quot;Second&quot;</span>);</code></pre><p>掌握 JavaScript 中 await 的执行顺序，是作为一名合格的 JavaScript 开发者的起点。但是如果你不小心把 JavaScript await 的执行顺序错误理解成所有编程语言的共性，那你很容易就会在 Elixir 开发中变成一名“不合格”的开发者。</p><p>因为 Elixir 中异步是真实的，JavaScript 中异步是模拟的（也可以说是基于事件循环的）。</p><p>请大家猜一下，下面 Elixir 代码的输入</p><pre><code>defmodule Demo do
  def foo(name) do
    IO.puts("#{name} start")
    Process.sleep(500)
    IO.puts("#{name} middle")
    Process.sleep(500)
    IO.puts("#{name} end")
  end
end

Task.async(fn -&gt; Demo.foo("First") end) |&gt; Task.await
Task.async(fn -&gt; Demo.foo("Second") end) |&gt; Task.await</code></pre><p>代码在评论区</p><h2 class="">为什么呢？</h2><p>主要区别</p><ul><li>JavaScript:<ul><li>单线程，使用事件循环来处理异步操作。</li><li>async/await 本质上是语法糖，底层仍是基于 Promise + 回调，依赖事件循环切换任务。</li><li>在同一个事件循环中，只有一个线程在执行 JS 代码，I/O 等操作异步回调回来后再执行。</li></ul></li><li>Elixir（BEAM 虚拟机）:<ul><li>天生支持并发，每个进程都非常轻量（与操作系统进程不同），可以同时在多核 CPU 上运行。</li><li>使用 Task.async/await、spawn 等方式来创建并发任务，内部有自己的调度器，能把这些任务分配到不同的调度线程上并行执行。</li><li>因为是真正并发，输出可能会交错出现，具体顺序并不保证。</li></ul></li></ul><p>所以，虽然 JavaScript 和 Elixir 中都有 async await 这两个关键字，但是它们的动作和底层机制都是一样的。</p><p>作为一名多语言使用者，我常常会因为熟练使用某一种语言，熟练到习以为常，而忘记其他语言的正确使用方法。编程语言如此，自然语言亦是如此。比如，我常常写错或读错中文和日文，比如：“天”。晕，我刚刚才意识到日本语和中文“天”字，在我的电脑上是一个字。😓</p><p>以上</p>
</div>


<div class="copyright">
<strong>
<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">
版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
</a>
</strong>
</div>

<style>
.copyright {
  padding: 0.5rem 1rem;
  text-align: center;
}

.copyright:hover {
  opacity: 0.9;
}
</style>



]]></description>
      <pubDate>Fri, 21 February 2025 10:53:27 -00:00</pubDate>
			<guid>https://thaddeusjiang.com/-tong-shi-shi-yong-duo-zhong-bian-cheng-yu-yan-xie-dai-ma-de-tong</guid>      
   </item>

   <item>
      <title>2025-01-07 refactorex</title>
      <link>https://thaddeusjiang.com/2025-01-07-refactorex</link>
			<description><![CDATA[
<div class="content">
  <p>为 ElixirLang 开发者推荐一款 VS Code 插件 refactorex，它通过扩展 VS Code Refactor 功能，提供了很多 elixir 常用的重构方法。它帮助我减少了很多无聊的键盘敲击，使用单一快捷键就可以实现超多类型的 Refactor，重构工作从枯燥无味变得十分愉悦，提升了我 Coding 的幸福感，希望你也会喜欢。</p><p>分享几个我觉得很爽的 Refactor</p><h2 class="">1. 下划线标注未使用的参数</h2><p><img class=" tc-image-loading" src="https://github.com/gp-pereira/refactorex/raw/main/assets/examples/function/underscore_unused_args.gif?raw=true"></p><p>下划线标注未使用的参数是 elixir 特色，其他语言应该也有类似风格，我不太确定。我知道 JavaScript 社区推荐把未使用的参数删掉，😂</p><h2 class="">2. 短函数</h2><p><img class=" tc-image-loading" src="https://github.com/gp-pereira/refactorex/raw/main/assets/examples/function/collapse_anonymous_function.gif?raw=true"></p><p>类似 <code>&amp;(&amp;1 + &amp;2)</code> 的匿名函数编写方式也是 elixir 特色，可以让代码变得非常简洁，易读。它似乎有另外一个名字叫 <code>Pointfree 风格</code>。</p><p>对比：</p><pre><code># before
items
|&gt; Enum.map(fn item -&gt; 
  item.price * (1- discount_rate)
end)
|&gt; Enum.sum()

# after
items
|&gt; Enum.map(&amp;(&amp;.price * (1- discount_rate)))
|&gt; Enum.sum()</code></pre><p>或许有人会不喜欢短函数，但是无所谓，我很喜欢 😄</p><h2 class="">3. 引入管道 （introduce pipeline）</h2><p><img class=" tc-image-loading" src="https://github.com/gp-pereira/refactorex/raw/main/assets/examples/pipeline/introduce_pipe.gif?raw=true"></p><p>pipeline 也是 elixir 特色。说实话，pipeline 是我喜欢 elixir 的一个非常重要的原因，pipeline 代码写起来非常爽，可以减少函数嵌套，并且可以避免大量临时变量，代码更清晰。</p><p>对比：</p><pre><code># before
Shipping.send_package(Shipping.new_package(items))

# after
items
|&gt; Shipping.new_package()
|&gt; shipping.send_package()</code></pre><h2 class="">小结</h2><p>你可能注意到了，我分享的 Refactor 都是极具 elixir 特色的。但是不用担心，其他编程语言常用的重构方法 refactorex 也提供，如提取函数、内联函数、重命名等等，更多内容请自行阅读 <a class="tc-tiddlylink-external" href="https://github.com/gp-pereira/refactorex" rel="noopener noreferrer" target="_blank">refactorex in GitHub</a></p><p>refs</p><ul><li><a class="tc-tiddlylink-external" href="https://marketplace.visualstudio.com/items?itemName=gp-pereira.refatorex" rel="noopener noreferrer" target="_blank">RefactorEx in VS Code Marketplace</a></li><li><a class="tc-tiddlylink-external" href="https://www.ruanyifeng.com/blog/2017/03/pointfree.html" rel="noopener noreferrer" target="_blank">Pointfree 编程风格指南</a></li></ul>
</div>


<div class="copyright">
<strong>
<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">
版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
</a>
</strong>
</div>

<style>
.copyright {
  padding: 0.5rem 1rem;
  text-align: center;
}

.copyright:hover {
  opacity: 0.9;
}
</style>



]]></description>
      <pubDate>Tue, 7 January 2025 7:23:41 -00:00</pubDate>
			<guid>https://thaddeusjiang.com/2025-01-07-refactorex</guid>      
   </item>

   <item>
      <title>2024-11-21 对事不对人</title>
      <link>https://thaddeusjiang.com/2024-11-21-dui-shi-bu-dui-ren</link>
			<description><![CDATA[
<div class="content">
  <p>几年前，我给自己定下一个规矩“不再评价任何人”。从那以后我讨论问题没有再从人出发，而仅仅讨论事情本身。</p><p>简单解释，无论马斯克做人怎么样，他在 SpaceX Tesla 以及其他方面，他都挺优秀的。大家总是攻击他这个人，现在我觉得没有必要了，看他做的事和成果比较客观。</p><p>我不明白为什么大家喜欢攻击人，而不是讨论事情。我想起一个段子“为什么中国人喜欢在辩论中进行人身攻击”，相关文章：
<a class="tc-tiddlylink-external" href="https://www.douban.com/group/topic/262139690/?_i=2179714VEA7LMK" rel="noopener noreferrer" target="_blank">https://www.douban.com/group/topic/262139690/?_i=2179714VEA7LMK</a></p><p>TL;DR</p><p>我们来假设一个问题，如果欧几里得先生被证明是一个精神病患者，那么几何学是否还成立？同样，假设牛顿先生后来被发现是一个罪犯，他的第一宇宙定律是否还成立？
中国人认为如果一个人被证明品质不好，那么他的理论和观点自然就是没有价值的。
那么＂把人搞臭＂就会永远成为中国人不得不选择的“证伪工具”。</p><p>为什么我想写这段文字？</p><ol><li>看到“何同学涉嫌抄袭”事件中 X.com 上网友表现</li><li>看到《再见爱人》在华语圈引发的讨论</li></ol><p>引用一位网友的话：“抓住一个机会就要把一个人彻底打倒，当代红卫兵开赛博批斗大会。” <a class="tc-tiddlylink-external" href="https://x.com/safaricheung/status/1858871535819427877" rel="noopener noreferrer" target="_blank">https://x.com/safaricheung/status/1858871535819427877</a></p><p>refs:</p><ul><li><a class="tc-tiddlylink-external" href="https://github.com/vietnh1009/ASCII-generator/issues/25" rel="noopener noreferrer" target="_blank">https://github.com/vietnh1009/ASCII-generator/issues/25</a></li></ul>
</div>


<div class="copyright">
<strong>
<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">
版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
</a>
</strong>
</div>

<style>
.copyright {
  padding: 0.5rem 1rem;
  text-align: center;
}

.copyright:hover {
  opacity: 0.9;
}
</style>



]]></description>
      <pubDate>Thu, 21 November 2024 9:18:23 -00:00</pubDate>
			<guid>https://thaddeusjiang.com/2024-11-21-dui-shi-bu-dui-ren</guid>      
   </item>

</channel>
</rss>
