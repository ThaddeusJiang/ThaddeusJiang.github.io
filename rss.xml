<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   <title>ThaddeusJiang</title>
   <link>https://thaddeusjiang.com</link>
   <description>Full Cycle Developer</description><follow_challenge>
    <feedId>41718658305983488</feedId>
    <userId>41718122139849728</userId>
</follow_challenge>
   <item>
      <title>2025-02-23 LiveView 异常处理</title>
      <link>https://thaddeusjiang.com/2025-02-23-liveview-yi-chang-chu-li</link>
			<description><![CDATA[
<div class="content">
  <p>因为太熟练 React 了，我曾经误以为 React ErrorBoundary 特性是 Web 标准，误以为 Elixir LiveView 中也有类似概念。但是 I was wrong</p><p>这是给 React developers 的一篇 LiveView 笔记，希望大家可以自由切换使用 React 和 LiveView ，不会再困惑。</p><blockquote><div>LiveView 是 Elixir 生态中流行的 UI framework。</div></blockquote><p>ErrorBoundary 是 React 的一个非常棒的特性，它实现了对异常处理的一种抽象，一种可以脱离数据的抽象，是一种 point-free style 的实践。</p><p>在 React 中，我们可以使用下面代码简单地处理各种异常。</p><pre class="hljs"><code class="jsx hljs">&lt;<span class="hljs-title class_">ErrorBoundary</span> fallback={<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Something went wrong<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>}&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Profile</span> /&gt;</span></span>
&lt;/<span class="hljs-title class_">ErrorBoundary</span>&gt;</code></pre><p>ErrorBoundary 可以统一处理各种异常：</p><ul><li>代码错误：例如对象 user 是 undefined，但代码中写了 user.id</li><li>第三方异常：例如 database 连接失败，文件读取失败</li></ul><h2 class="">LiveView 中没有类似 React ErrorBoundary 的特性</h2><p>主要原因是 Elixir 对于错误的处理方式和 JavaScript 的哲学不一样，Elixir 继承了 Erlang 的 "Let It Crash" 哲学。所以，当 LiveView 中出现异常时，Elixir 会重启出现异常的进程，而不是让整个系统崩溃。</p><p>因为 LiveView 进程在出现错误时会被重启，所以我们通过 handle_info/2 监听 :EXIT 消息，自定义异常处理。</p><p>实例代码：</p><pre><code>defmodule MyAppWeb.MyLive do
  use Phoenix.LiveView

  def mount(_params, _session, socket) do
    Process.flag(:trap_exit, true) # 允许捕获进程崩溃信息
    {:ok, socket}
  end

  def handle_info({:EXIT, _from, reason}, socket) do
    IO.inspect(reason, label: "LiveView crashed with reason")
    {:noreply, assign(socket, error: "Something went wrong")}
  end

  def render(assigns) do
    ~H"""
    &lt;div&gt;
      &lt;%= if @error do %&gt;
        &lt;p class="error"&gt;&lt;%= @error %&gt;&lt;/p&gt;
      &lt;% else %&gt;
        &lt;p&gt;正常显示内容&lt;/p&gt;
      &lt;% end %&gt;
    &lt;/div&gt;
    """
  end
end</code></pre><h2 class="">总结</h2><ol><li>ErrorBoundary 是 React 的特性，不是 Web Standards，LiveView 没有这个概念。</li><li>LiveView 异常处理继承自 Elixir/Erlang 的“崩溃并由监督树管理重启”的哲学</li><li>异常处理有两种风格：依赖异常的、不依赖异常的。React ErrorBoundary 和 Elixir Supervisor 都是不依赖异常的，golang if(!error) 是依赖异常的。</li></ol><blockquote><div>imo: LiveView 提供类似 React 一样的 UI 开发体验，在 state management 和 components 方面也十分优秀，在 data query 和 data mutation 方面甚至比 React 体验更棒，集成第三方 JS library 的方法更简单。</div></blockquote><p>最后，希望大家可以自由切换使用 React 和 LiveView ，它们都非常优秀，但是它们的设计哲学和思想有本质的不同，需要时刻提醒自己不要模糊它们的界限。</p><p>以上，感谢阅读。</p><h2 class="">refs</h2><ul><li><a class="tc-tiddlylink-external" href="https://www.phoenixframework.org/blog/phoenix-liveview-1.0-released" rel="noopener noreferrer" target="_blank">https://www.phoenixframework.org/blog/phoenix-liveview-1.0-released</a></li><li><a class="tc-tiddlylink-external" href="https://github.com/bvaughn/react-error-boundary" rel="noopener noreferrer" target="_blank">https://github.com/bvaughn/react-error-boundary</a></li><li><a class="tc-tiddlylink-external" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener noreferrer" target="_blank">https://reactjs.org/docs/error-boundaries.html</a></li></ul>
</div>


<div class="copyright">
<strong>
<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">
版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
</a>
</strong>
</div>

<style>
.copyright {
  padding: 0.5rem 1rem;
  text-align: center;
}

.copyright:hover {
  opacity: 0.9;
}
</style>



]]></description>
      <pubDate>Sun, 23 February 2025 8:16:19 -00:00</pubDate>
			<guid>https://thaddeusjiang.com/2025-02-23-liveview-yi-chang-chu-li</guid>      
   </item>

   <item>
      <title>2025-02-21 同时使用多种编程语言写代码的痛</title>
      <link>https://thaddeusjiang.com/2025-02-21-tong-shi-shi-yong-duo-zhong-bian-cheng-yu-yan-xie-dai-ma-de-tong</link>
			<description><![CDATA[
<div class="content">
  <p>我觉得“痛”这个词也不恰当，但是我也知道该用哪个词来形容。我考虑过“困境”、“难点”、“不爽”、“苦楚”等等，都不太恰当。</p><p>算了，我还是来形容一下场景吧。</p><p>我是一名多语言使用者，编程时同时用 JavaScript 和 Elixir，日常生活中、日、英混杂。</p><p>因为使用 JavaScript 的频率太高了，有时我会把 JavaScript 的某些特性误以为是编程语言的共同特性，例如：await 。</p><p>相信，所有合格的 JavaScript 开发者都知道下面这段代码的输出：</p><pre class="hljs"><code class="js hljs"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, <span class="hljs-string">&quot;start&quot;</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, <span class="hljs-string">&quot;middle&quot;</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, <span class="hljs-string">&quot;end&quot;</span>);
}

<span class="hljs-title function_">foo</span>(<span class="hljs-string">&quot;First&quot;</span>);
<span class="hljs-title function_">foo</span>(<span class="hljs-string">&quot;Second&quot;</span>);</code></pre><p>掌握 JavaScript 中 await 的执行顺序，是作为一名合格的 JavaScript 开发者的起点。但是如果你不小心把 JavaScript await 的执行顺序错误理解成所有编程语言的共性，那你很容易就会在 Elixir 开发中变成一名“不合格”的开发者。</p><p>因为 Elixir 中异步是真实的，JavaScript 中异步是模拟的（也可以说是基于事件循环的）。</p><p>请大家猜一下，下面 Elixir 代码的输入</p><pre><code>defmodule Demo do
  def foo(name) do
    IO.puts("#{name} start")
    Process.sleep(500)
    IO.puts("#{name} middle")
    Process.sleep(500)
    IO.puts("#{name} end")
  end
end

Task.async(fn -&gt; Demo.foo("First") end) |&gt; Task.await
Task.async(fn -&gt; Demo.foo("Second") end) |&gt; Task.await</code></pre><p>代码在评论区</p><h2 class="">为什么呢？</h2><p>主要区别</p><ul><li>JavaScript:<ul><li>单线程，使用事件循环来处理异步操作。</li><li>async/await 本质上是语法糖，底层仍是基于 Promise + 回调，依赖事件循环切换任务。</li><li>在同一个事件循环中，只有一个线程在执行 JS 代码，I/O 等操作异步回调回来后再执行。</li></ul></li><li>Elixir（BEAM 虚拟机）:<ul><li>天生支持并发，每个进程都非常轻量（与操作系统进程不同），可以同时在多核 CPU 上运行。</li><li>使用 Task.async/await、spawn 等方式来创建并发任务，内部有自己的调度器，能把这些任务分配到不同的调度线程上并行执行。</li><li>因为是真正并发，输出可能会交错出现，具体顺序并不保证。</li></ul></li></ul><p>所以，虽然 JavaScript 和 Elixir 中都有 async await 这两个关键字，但是它们的动作和底层机制都是不一样的。</p><p>作为一名多语言使用者，我常常会因为熟练使用某一种语言，熟练到习以为常，而忘记其他语言的正确使用方法。编程语言如此，自然语言亦是如此。</p><p>在日本生活久了的人，无论曾经英语有多少，几乎都会忘记“电梯”的英文发音，😂</p><p>推荐一个介绍 JapanEnglish 的视频，<a class="tc-tiddlylink-external" href="https://youtu.be/q7y4av-Dr4I?si=DdJwLJapaif4CajG&amp;t=40" rel="noopener noreferrer" target="_blank">https://youtu.be/q7y4av-Dr4I?si=DdJwLJapaif4CajG&amp;t=40</a></p><p>以上</p>
</div>


<div class="copyright">
<strong>
<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">
版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
</a>
</strong>
</div>

<style>
.copyright {
  padding: 0.5rem 1rem;
  text-align: center;
}

.copyright:hover {
  opacity: 0.9;
}
</style>



]]></description>
      <pubDate>Fri, 21 February 2025 10:53:27 -00:00</pubDate>
			<guid>https://thaddeusjiang.com/2025-02-21-tong-shi-shi-yong-duo-zhong-bian-cheng-yu-yan-xie-dai-ma-de-tong</guid>      
   </item>

   <item>
      <title>2025-01-07 refactorex</title>
      <link>https://thaddeusjiang.com/2025-01-07-refactorex</link>
			<description><![CDATA[
<div class="content">
  <p>为 ElixirLang 开发者推荐一款 VS Code 插件 refactorex，它通过扩展 VS Code Refactor 功能，提供了很多 elixir 常用的重构方法。它帮助我减少了很多无聊的键盘敲击，使用单一快捷键就可以实现超多类型的 Refactor，重构工作从枯燥无味变得十分愉悦，提升了我 Coding 的幸福感，希望你也会喜欢。</p><p>分享几个我觉得很爽的 Refactor</p><h2 class="">1. 下划线标注未使用的参数</h2><p><img class=" tc-image-loading" src="https://github.com/gp-pereira/refactorex/raw/main/assets/examples/function/underscore_unused_args.gif?raw=true"></p><p>下划线标注未使用的参数是 elixir 特色，其他语言应该也有类似风格，我不太确定。我知道 JavaScript 社区推荐把未使用的参数删掉，😂</p><h2 class="">2. 短函数</h2><p><img class=" tc-image-loading" src="https://github.com/gp-pereira/refactorex/raw/main/assets/examples/function/collapse_anonymous_function.gif?raw=true"></p><p>类似 <code>&amp;(&amp;1 + &amp;2)</code> 的匿名函数编写方式也是 elixir 特色，可以让代码变得非常简洁，易读。它似乎有另外一个名字叫 <code>Pointfree 风格</code>。</p><p>对比：</p><pre><code># before
items
|&gt; Enum.map(fn item -&gt; 
  item.price * (1- discount_rate)
end)
|&gt; Enum.sum()

# after
items
|&gt; Enum.map(&amp;(&amp;.price * (1- discount_rate)))
|&gt; Enum.sum()</code></pre><p>或许有人会不喜欢短函数，但是无所谓，我很喜欢 😄</p><h2 class="">3. 引入管道 （introduce pipeline）</h2><p><img class=" tc-image-loading" src="https://github.com/gp-pereira/refactorex/raw/main/assets/examples/pipeline/introduce_pipe.gif?raw=true"></p><p>pipeline 也是 elixir 特色。说实话，pipeline 是我喜欢 elixir 的一个非常重要的原因，pipeline 代码写起来非常爽，可以减少函数嵌套，并且可以避免大量临时变量，代码更清晰。</p><p>对比：</p><pre><code># before
Shipping.send_package(Shipping.new_package(items))

# after
items
|&gt; Shipping.new_package()
|&gt; shipping.send_package()</code></pre><h2 class="">小结</h2><p>你可能注意到了，我分享的 Refactor 都是极具 elixir 特色的。但是不用担心，其他编程语言常用的重构方法 refactorex 也提供，如提取函数、内联函数、重命名等等，更多内容请自行阅读 <a class="tc-tiddlylink-external" href="https://github.com/gp-pereira/refactorex" rel="noopener noreferrer" target="_blank">refactorex in GitHub</a></p><p>refs</p><ul><li><a class="tc-tiddlylink-external" href="https://marketplace.visualstudio.com/items?itemName=gp-pereira.refatorex" rel="noopener noreferrer" target="_blank">RefactorEx in VS Code Marketplace</a></li><li><a class="tc-tiddlylink-external" href="https://www.ruanyifeng.com/blog/2017/03/pointfree.html" rel="noopener noreferrer" target="_blank">Pointfree 编程风格指南</a></li></ul>
</div>


<div class="copyright">
<strong>
<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">
版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
</a>
</strong>
</div>

<style>
.copyright {
  padding: 0.5rem 1rem;
  text-align: center;
}

.copyright:hover {
  opacity: 0.9;
}
</style>



]]></description>
      <pubDate>Tue, 7 January 2025 7:23:41 -00:00</pubDate>
			<guid>https://thaddeusjiang.com/2025-01-07-refactorex</guid>      
   </item>

</channel>
</rss>
