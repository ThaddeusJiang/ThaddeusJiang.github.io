<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   <title>Thaddeus Jiang</title>
   <link>https://thaddeusjiang.com</link>
   <description>I know I don't know, stay curious.</description>
   <item>
      <title>2024-05-08 关于 MVP 我的认知改变了</title>
      <link>https://thaddeusjiang.com/2024-05-08-guan-yu-mvp-wo-de-ren-zhi-gai-bian-liao</link>
			<description><![CDATA[
<div class="container">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2 my-4"><nav aria-label="main navigation" class="navbar" role="navigation"><p><div class="navbar-brand">
          <a href="./">
              <h1 class="title">Thaddeus Jiang</h1>
              <p class="subtitle">I know I don't know, stay curious.</p>
          </a>
      </div></p><p><div class="navbar-end mt-2 subtitle is-5"><a class="tc-tiddlylink tc-tiddlylink-shadow tc-tiddlylink-resolves" href="./#blog">Posts</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/wiki" rel="noopener noreferrer" target="_blank">Wiki</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/rss.xml" rel="noopener noreferrer" target="_blank">RSS</a> </div></p></nav></div>
</div>


<div class="container mt-4">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2">
      <div>
          <div class="block content blog">
            <h1 class="subtitle">2024-05-08 关于 MVP 我的认知改变了</h1>
            <hr>

            <p>关于计算机领域的 MVP 有一张广为流传的图片，大致的意思是造一辆汽车，正确的顺序是先造一个滑板；再造手扶滑板；再造自行车；再造摩托车，再造汽车。我曾经也分享过很多次，并解释的头头是道。但是，这张广为流传的图讲的真的有道理吗？</p><p><img class=" tc-image-loading" src="https://github.com/ThaddeusJiang/thaddeusjiang.github.io/assets/17308201/4d711350-2725-4d46-aa14-08463dcf6839"></p><p>Q：如果我们想造一辆汽车，我们真的需要先造滑板、自行车、摩托车吗？</p><p>我的答案是：No，不需要。</p><p>让我们重新认真想一下，如果你想要向你的客户交付一辆汽车，并且预期期限是 3年后。</p><ul><li>你的客户真的需要你在第一个月就给他一辆滑板让他先玩着吗？</li><li>你真的需要你的客户根据他玩滑板的体验，给你提一些修改意见吗？</li><li>你是想给客户提供一辆汽车，还是想绑住客户 3年的时间，赚3年的钱，至于最后给客户了什么你根本就不在乎？反正你每个月都给客户了某种意义上的 MVP，你有借口推脱了，钱也赚了，说不定还能继续忽悠客户继续赚钱。</li></ul><p>让我们一起观察一下，有哪个产品是采用如图所示的方式创造的？</p><ul><li>iPhone 在发布之前，Apple 公司给用户简单的功能机并寻求 feedback 了吗？</li><li>Tesla 的电动汽车在发布之前先造了滑板车、自行车、摩托车，最后造汽车吗？</li><li>ChatGPT 发布之前是先开发了一个静态网页，再开发一个对话应用，最后开发出 ChatGPT 的吗？</li></ul><p>好像都没有。既然我们熟知的优秀的、有价值的、伟大的产品都不是参照图如所示的 MVP 流程开发的，这张图流行的依据到底是什么？会不会就是盲从呢？</p><p>既然从滑板车到汽车的流程不合理，那有没有更合理的流程呢？</p><p>我找到了另外一张图，大致的意思是：先找一辆汽车（即使不能开也行），然后让它能开，然后再往期待的方向改进。</p><p><img class=" tc-image-loading" src="https://york.ie/wp-content/uploads/2022/09/MVP_MVA_Car_Diagram.png"></p><p>我觉得比较合理，不知道大家怎么看？</p><p>最后说一句，这种模式好像以前流行过一阵子，好像叫“石头汤”。😂
</p>
          </div>          
      </div>
  </div>
</div>     


<div class="copyright">
<strong>
<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">
版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
</a>
</strong>
</div>

<style>
.copyright {
  padding: 0.5rem 1rem;
  text-align: center;
}

.copyright:hover {
  opacity: 0.9;
}
</style>


]]></description>
      <pubDate>Tue, 7 May 2024 17:36:54 -00:00</pubDate>
			<guid>https://thaddeusjiang.com/2024-05-08-guan-yu-mvp-wo-de-ren-zhi-gai-bian-liao</guid>      
   </item>

   <item>
      <title>2024-04-11 Remix 改变了我编写 dialog 的方式</title>
      <link>https://thaddeusjiang.com/2024-04-11-remix-gai-bian-liao-wo-bian-xie-dialog-de-fang-shi</link>
			<description><![CDATA[
<div class="container">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2 my-4"><nav aria-label="main navigation" class="navbar" role="navigation"><p><div class="navbar-brand">
          <a href="./">
              <h1 class="title">Thaddeus Jiang</h1>
              <p class="subtitle">I know I don't know, stay curious.</p>
          </a>
      </div></p><p><div class="navbar-end mt-2 subtitle is-5"><a class="tc-tiddlylink tc-tiddlylink-shadow tc-tiddlylink-resolves" href="./#blog">Posts</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/wiki" rel="noopener noreferrer" target="_blank">Wiki</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/rss.xml" rel="noopener noreferrer" target="_blank">RSS</a> </div></p></nav></div>
</div>


<div class="container mt-4">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2">
      <div>
          <div class="block content blog">
            <h1 class="subtitle">2024-04-11 Remix 改变了我编写 dialog 的方式</h1>
            <hr>

            <p>关于 dialog（对话框），回想一下，我的代码经历过好几次变化，使用 React 之前，React 初级阶段，目前部分项目使用原生 HTML 部分项目使用 Remix framework。</p><p>tl;dr</p><ol><li>React 之前：命令式，例如 window.alert(message)</li><li>React 初期：all in 声明式，例如：[isOpen, setIsOpen] = useState(true)</li><li>采用 Radix UI 阶段：借助 DialogTrigger</li><li>daisyUI 相关项目： 回归 HTML native dialog</li><li>Remix 相关项目：设计 Modal Route</li></ol><h1 class="">React 之前：命令式</h1><p>React 之前使用过 jQuery, Ext JS, pure JS 编写 UI，一般使用命令式编写 dialog UI。</p><pre class="hljs"><code class="js hljs"><span class="hljs-comment">// jQuery code</span>
$(<span class="hljs-string">&quot;#boring&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  $.<span class="hljs-title function_">dialog</span>({
    <span class="hljs-string">&quot;body&quot;</span>: <span class="hljs-string">&quot;jQueryScript.net!&quot;</span>,
    <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;jQuery Dialog Plugin Demo&quot;</span>,
    <span class="hljs-string">&quot;show&quot;</span>: <span class="hljs-literal">true</span>
  });
});

<span class="hljs-comment">// pure JS</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello world&quot;</span>)

<span class="hljs-comment">// sweetalert2</span>
<span class="hljs-title class_">Swal</span>.<span class="hljs-title function_">fire</span>({
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Good job!&quot;</span>,
  <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;You clicked the button!&quot;</span>,
  <span class="hljs-attr">icon</span>: <span class="hljs-string">&quot;success&quot;</span>
});</code></pre><h1 class="">React 初期：all in 声明式</h1><p>刚开始使用 React 时，几乎都有代码都是声明式的，一般如下：</p><pre class="hljs"><code class="jsx hljs">  <span class="hljs-keyword">let</span> [isOpen, setIsOpen] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>)

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">closeModal</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">setIsOpen</span>(<span class="hljs-literal">false</span>)
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">openModal</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">setIsOpen</span>(<span class="hljs-literal">true</span>)
  }


  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{openModal}</span>&gt;</span>open<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Dialog</span> <span class="hljs-attr">open</span>=<span class="hljs-string">{isOpen}</span> <span class="hljs-attr">onClose</span>=<span class="hljs-string">{closeModal}</span> &gt;</span>
        {* ... *}
      <span class="hljs-tag">&lt;/<span class="hljs-name">Dialog</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  ) </code></pre><p>不过这种写法有很多问题：</p><ol><li>如果只是想实现类似 alert 的提醒功能，useState 一套下来，无用代码爆炸</li><li>有时需要在 API request 过程中处理 dialog，但是 dialog 显示与否被绑定在 UI 中， 不利于代码拆分。<ol><li>根据 API request 结果处理 dialog 也需要写一堆 if-else </li></ol></li></ol><h1 class="">采用 Radix UI 阶段：借助 DialogTrigger </h1><pre class="hljs"><code class="jsx hljs">&lt;<span class="hljs-title class_">AlertDialog</span>&gt;
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AlertDialogTrigger</span> <span class="hljs-attr">asChild</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">variant</span>=<span class="hljs-string">&quot;outline&quot;</span>&gt;</span>Show Dialog<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">AlertDialogTrigger</span>&gt;</span></span>
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AlertDialogContent</span>&gt;</span>
      {* ... *}
      <span class="hljs-tag">&lt;/<span class="hljs-name">AlertDialogContent</span>&gt;</span></span>
&lt;/<span class="hljs-title class_">AlertDialog</span>&gt;</code></pre><p>使用一个 AlertDialogTrigger 可以避免 useState 爆炸，算是一点点改善🤏</p><h1 class="">daisyUI 相关项目： 回归 HTML native dialog</h1><pre class="hljs"><code class="html hljs">
<span class="hljs-tag">&lt;<span class="hljs-name">dialog</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;my_modal_2&quot;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal-box&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;font-bold text-lg&quot;</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;py-4&quot;</span>&gt;</span>Press ESC key or click outside to close<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;dialog&quot;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal-backdrop&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>close<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span>

// close dialog
document.getElementById(&#x27;my_modal_2&#x27;).showModal()</code></pre><p>这种方式不仅避免了 useState 爆炸，又可以在任意时机操作 dialog。很棒。</p><p>缺点就是在 React 项目中需要一个 useRef 配合。</p><pre class="hljs"><code class="jsx hljs">  <span class="hljs-keyword">const</span> dialogRef = useRef&lt;<span class="hljs-title class_">HTMLDialogElement</span>&gt;(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">open</span>(<span class="hljs-params"></span>) {
    dialogRef.<span class="hljs-property">current</span>?.<span class="hljs-title function_">showModal</span>();
  }

  &lt;dialog ref={dialogRef} className=<span class="hljs-string">&quot;modal&quot;</span>&gt;
    {* ... *}
  &lt;/dialog&gt;</code></pre><h1 class="">Remix 相关项目：设计 Modal Route</h1><p>在需要使用 Modal 的页面中埋下一个 <code>&lt;Outlet /&gt;</code>，然后实现一个 Modal Route 如下：</p><pre class="hljs"><code class="jsx hljs"><span class="hljs-comment">// members.$id.tsx</span>
&lt;<span class="hljs-title class_">Link</span> to={<span class="hljs-string">&quot;disable&quot;</span>}&gt;disable&lt;/<span class="hljs-title class_">Link</span>&gt;

<span class="hljs-comment">// members.$id.disable.tsx</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">action</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// your code</span>
  
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">redirect</span>(<span class="hljs-string">&quot;/members/${id}&quot;</span>)
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MemberDisableRoute</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> navigate = <span class="hljs-title function_">useNavigate</span>()
    <span class="hljs-keyword">return</span> (
        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dialog</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{props.title}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal modal-open&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal-box&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;font-bold text-lg&quot;</span>&gt;</span>Are you sure?<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal-action&quot;</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> navigate(-1)}&gt;Cancel<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">Form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">hidden</span> /&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>Yes<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-name">Form</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span></span>
    );
}</code></pre><p>不仅没有 useState 数量爆炸，也不需要手工维护 dialog 状态。</p><p>其他优点：</p><ol><li>更合理的拆分业务逻辑，disable UI 和 API 和 member detail 完全隔离，更容易测试。</li><li>更容易处理 page 状态。例如多个表单的提交状态，以前常常会出现 form1.submitting || form2.submitting 的问题，现在只需要进行页面跳转即可。</li><li>更容易处理多级弹窗。只需要简单重复 Outlet 即可，避免了多层嵌套。</li></ol><p>缺点：</p><ul><li>框架依赖。这是 Remix Nested Routes 前提下的实现方案，不是 Web Standards。</li></ul><p>背景资料：</p><ul><li><a class="tc-tiddlylink-external" href="https://www.jqueryscript.net/demo/Simple-jQuery-Modal-Dialog-Box-Plugin-Dialog/" rel="noopener noreferrer" target="_blank">https://www.jqueryscript.net/demo/Simple-jQuery-Modal-Dialog-Box-Plugin-Dialog/</a></li><li><a class="tc-tiddlylink-external" href="https://sweetalert2.github.io/" rel="noopener noreferrer" target="_blank">https://sweetalert2.github.io/</a></li><li><a class="tc-tiddlylink-external" href="https://www.radix-ui.com/primitives/docs/components/alert-dialog" rel="noopener noreferrer" target="_blank">https://www.radix-ui.com/primitives/docs/components/alert-dialog</a></li><li><a class="tc-tiddlylink-external" href="https://daisyui.com/components/modal/" rel="noopener noreferrer" target="_blank">https://daisyui.com/components/modal/</a></li><li><a class="tc-tiddlylink-external" href="https://remix.run/docs/en/main/file-conventions/routes#nested-routes" rel="noopener noreferrer" target="_blank">https://remix.run/docs/en/main/file-conventions/routes#nested-routes</a></li></ul>
          </div>          
      </div>
  </div>
</div>     


<div class="copyright">
<strong>
<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">
版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
</a>
</strong>
</div>

<style>
.copyright {
  padding: 0.5rem 1rem;
  text-align: center;
}

.copyright:hover {
  opacity: 0.9;
}
</style>


]]></description>
      <pubDate>Thu, 11 April 2024 10:6:24 -00:00</pubDate>
			<guid>https://thaddeusjiang.com/2024-04-11-remix-gai-bian-liao-wo-bian-xie-dialog-de-fang-shi</guid>      
   </item>

   <item>
      <title>2024-03-12 JS REPL become useful</title>
      <link>https://thaddeusjiang.com/2024-03-12-js-repl-become-useful</link>
			<description><![CDATA[
<div class="container">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2 my-4"><nav aria-label="main navigation" class="navbar" role="navigation"><p><div class="navbar-brand">
          <a href="./">
              <h1 class="title">Thaddeus Jiang</h1>
              <p class="subtitle">I know I don't know, stay curious.</p>
          </a>
      </div></p><p><div class="navbar-end mt-2 subtitle is-5"><a class="tc-tiddlylink tc-tiddlylink-shadow tc-tiddlylink-resolves" href="./#blog">Posts</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/wiki" rel="noopener noreferrer" target="_blank">Wiki</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/rss.xml" rel="noopener noreferrer" target="_blank">RSS</a> </div></p></nav></div>
</div>


<div class="container mt-4">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2">
      <div>
          <div class="block content blog">
            <h1 class="subtitle">2024-03-12 JS REPL become useful</h1>
            <hr>

            <p>一直以来我一直在寻找一个 JS 工具，可以让我不退出 console (REPL) 就直接安装新的依赖。Thanks God. 我终于找到了。🥳</p><p><code>bun repl</code> is so cool. </p><p>Demo: </p><pre class="hljs"><code class="sh hljs">bun repl

&gt; import dayjs from <span class="hljs-string">&quot;dayjs&quot;</span>
&gt; dayjs().toISOString()
<span class="hljs-string">&#x27;2024-03-12T01:41:09.763Z&#x27;</span></code></pre><h2 class="">Why I want to install dependencies in console?</h2><p>很多时候我只是想运行某个函数，而不是写代码。在 bun repl 之前我一直使用 RunKit.com 做这件事。但是 RunKit 有一个很重要的不足，就是不支持 ESM ，因为我日常工作已经全面切换到 ESM，每次在 RunKit 中写 require("somelib") 让我觉得十分割裂。</p><p>或许对于很多人来说，npm i -y ，然后 npm install dayjs 也是一个不错的选择。但是我个人不喜欢在 local 留下太多临时代码，并且 node_modules 真的太占存储空间了。我还是喜欢在 console 中“用完即弃”。</p><h2 class="">Where I learn this Tips?</h2><p>1. Elixir iex shell 提供这个功能</p><pre><code>iex

iex&gt; Mix.install(  [{:timex, "~&gt; 3.0"}])
iex&gt; Timex.now
~U[2024-03-12 01:57:40.350390Z]</code></pre><p>作为一个老派程序员，我真的无法使用没有 REPL 的编程语言。REPL 不好用的话和没有没有区别，node 直接开启的那个运行环境根本就不算一个合格的 REPL。</p><pre class="hljs"><code class="sh hljs">node        
Welcome to Node.js v18.14.0.
Type <span class="hljs-string">&quot;.help&quot;</span> <span class="hljs-keyword">for</span> more information.
&gt; npm install dayjs
npm should be run outside of the Node.js REPL, <span class="hljs-keyword">in</span> your normal shell.
(Press Ctrl+D to <span class="hljs-built_in">exit</span>.)
&gt; 
&gt; import dayjs from <span class="hljs-string">&quot;dayjs&quot;</span>
import dayjs from <span class="hljs-string">&quot;dayjs&quot;</span>
^^^^^^

Uncaught:
SyntaxError: Cannot use import statement inside the Node.js REPL, alternatively use dynamic import</code></pre><p>refs:</p><ul><li><a class="tc-tiddlylink-external" href="https://github.com/jhmaster2000/bun-repl" rel="noopener noreferrer" target="_blank">https://github.com/jhmaster2000/bun-repl</a></li></ul>
          </div>          
      </div>
  </div>
</div>     


<div class="copyright">
<strong>
<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">
版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
</a>
</strong>
</div>

<style>
.copyright {
  padding: 0.5rem 1rem;
  text-align: center;
}

.copyright:hover {
  opacity: 0.9;
}
</style>


]]></description>
      <pubDate>Tue, 12 March 2024 2:3:55 -00:00</pubDate>
			<guid>https://thaddeusjiang.com/2024-03-12-js-repl-become-useful</guid>      
   </item>

</channel>
</rss>
