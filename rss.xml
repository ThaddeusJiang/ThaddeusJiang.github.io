<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   <title>Thaddeus Jiang</title>
   <link>https://thaddeusjiang.com</link>
   <description>I know I don't know, stay curious.</description>
   <item>
      <title>2024-04-11 Remix 改变了我编写 dialog 的方式</title>
      <link>https://thaddeusjiang.com/2024-04-11-remix-gai-bian-liao-wo-bian-xie-dialog-de-fang-shi</link>
			<description><![CDATA[
<div class="container">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2 my-4"><nav aria-label="main navigation" class="navbar" role="navigation"><p><div class="navbar-brand">
          <a href="./">
              <h1 class="title">Thaddeus Jiang</h1>
              <p class="subtitle">I know I don't know, stay curious.</p>
          </a>
      </div></p><p><div class="navbar-end mt-2 subtitle is-5"><a class="tc-tiddlylink tc-tiddlylink-shadow tc-tiddlylink-resolves" href="./#blog">Posts</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/wiki" rel="noopener noreferrer" target="_blank">Wiki</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/rss.xml" rel="noopener noreferrer" target="_blank">RSS</a> </div></p></nav></div>
</div>


<div class="container mt-4">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2">
      <div>
          <div class="block content blog">
            <h1 class="subtitle">2024-04-11 Remix 改变了我编写 dialog 的方式</h1>
            <hr>

            <p>关于 dialog（对话框），回想一下，我的代码经历过好几次变化，使用 React 之前，React 初级阶段，目前部分项目使用原生 HTML 部分项目使用 Remix framework。</p><p>tl;dr</p><ol><li>React 之前：命令式，例如 window.alert(message)</li><li>React 初期：all in 声明式，例如：[isOpen, setIsOpen] = useState(true)</li><li>采用 Radix UI 阶段：借助 DialogTrigger</li><li>daisyUI 相关项目： 回归 HTML native dialog</li><li>Remix 相关项目：设计 Modal Route</li></ol><h1 class="">React 之前：命令式</h1><p>React 之前使用过 jQuery, Ext JS, pure JS 编写 UI，一般使用命令式编写 dialog UI。</p><pre class="hljs"><code class="js hljs"><span class="hljs-comment">// jQuery code</span>
$(<span class="hljs-string">&quot;#boring&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  $.<span class="hljs-title function_">dialog</span>({
    <span class="hljs-string">&quot;body&quot;</span>: <span class="hljs-string">&quot;jQueryScript.net!&quot;</span>,
    <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;jQuery Dialog Plugin Demo&quot;</span>,
    <span class="hljs-string">&quot;show&quot;</span>: <span class="hljs-literal">true</span>
  });
});

<span class="hljs-comment">// pure JS</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello world&quot;</span>)

<span class="hljs-comment">// sweetalert2</span>
<span class="hljs-title class_">Swal</span>.<span class="hljs-title function_">fire</span>({
  <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Good job!&quot;</span>,
  <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;You clicked the button!&quot;</span>,
  <span class="hljs-attr">icon</span>: <span class="hljs-string">&quot;success&quot;</span>
});</code></pre><h1 class="">React 初期：all in 声明式</h1><p>刚开始使用 React 时，几乎都有代码都是声明式的，一般如下：</p><pre class="hljs"><code class="jsx hljs">  <span class="hljs-keyword">let</span> [isOpen, setIsOpen] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>)

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">closeModal</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">setIsOpen</span>(<span class="hljs-literal">false</span>)
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">openModal</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">setIsOpen</span>(<span class="hljs-literal">true</span>)
  }


  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{openModal}</span>&gt;</span>open<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Dialog</span> <span class="hljs-attr">open</span>=<span class="hljs-string">{isOpen}</span> <span class="hljs-attr">onClose</span>=<span class="hljs-string">{closeModal}</span> &gt;</span>
        {* ... *}
      <span class="hljs-tag">&lt;/<span class="hljs-name">Dialog</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  ) </code></pre><p>不过这种写法有很多问题：</p><ol><li>如果只是想实现类似 alert 的提醒功能，useState 一套下来，无用代码爆炸</li><li>有时需要在 API request 过程中处理 dialog，但是 dialog 显示与否被绑定在 UI 中， 不利于代码拆分。<ol><li>根据 API request 结果处理 dialog 也需要写一堆 if-else </li></ol></li></ol><h1 class="">采用 Radix UI 阶段：借助 DialogTrigger </h1><pre class="hljs"><code class="jsx hljs">&lt;<span class="hljs-title class_">AlertDialog</span>&gt;
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AlertDialogTrigger</span> <span class="hljs-attr">asChild</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">variant</span>=<span class="hljs-string">&quot;outline&quot;</span>&gt;</span>Show Dialog<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">AlertDialogTrigger</span>&gt;</span></span>
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">AlertDialogContent</span>&gt;</span>
      {* ... *}
      <span class="hljs-tag">&lt;/<span class="hljs-name">AlertDialogContent</span>&gt;</span></span>
&lt;/<span class="hljs-title class_">AlertDialog</span>&gt;</code></pre><p>使用一个 AlertDialogTrigger 可以避免 useState 爆炸，算是一点点改善🤏</p><h1 class="">daisyUI 相关项目： 回归 HTML native dialog</h1><pre class="hljs"><code class="html hljs">
<span class="hljs-tag">&lt;<span class="hljs-name">dialog</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;my_modal_2&quot;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal-box&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;font-bold text-lg&quot;</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;py-4&quot;</span>&gt;</span>Press ESC key or click outside to close<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;dialog&quot;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal-backdrop&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>close<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span>

// close dialog
document.getElementById(&#x27;my_modal_2&#x27;).showModal()</code></pre><p>这种方式不仅避免了 useState 爆炸，又可以在任意时机操作 dialog。很棒。</p><p>缺点就是在 React 项目中需要一个 useRef 配合。</p><pre class="hljs"><code class="jsx hljs">  <span class="hljs-keyword">const</span> dialogRef = useRef&lt;<span class="hljs-title class_">HTMLDialogElement</span>&gt;(<span class="hljs-literal">null</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">open</span>(<span class="hljs-params"></span>) {
    dialogRef.<span class="hljs-property">current</span>?.<span class="hljs-title function_">showModal</span>();
  }

  &lt;dialog ref={dialogRef} className=<span class="hljs-string">&quot;modal&quot;</span>&gt;
    {* ... *}
  &lt;/dialog&gt;</code></pre><h1 class="">Remix 相关项目：设计 Modal Route</h1><p>在需要使用 Modal 的页面中埋下一个 <code>&lt;Outlet /&gt;</code>，然后实现一个 Modal Route 如下：</p><pre class="hljs"><code class="jsx hljs"><span class="hljs-comment">// members.$id.tsx</span>
&lt;<span class="hljs-title class_">Link</span> to={<span class="hljs-string">&quot;disable&quot;</span>}&gt;disable&lt;/<span class="hljs-title class_">Link</span>&gt;

<span class="hljs-comment">// members.$id.disable.tsx</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">action</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// your code</span>
  
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">redirect</span>(<span class="hljs-string">&quot;/members/${id}&quot;</span>)
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MemberDisableRoute</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> navigate = <span class="hljs-title function_">useNavigate</span>()
    <span class="hljs-keyword">return</span> (
        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dialog</span> <span class="hljs-attr">id</span>=<span class="hljs-string">{props.title}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal modal-open&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal-box&quot;</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;font-bold text-lg&quot;</span>&gt;</span>Are you sure?<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;modal-action&quot;</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> navigate(-1)}&gt;Cancel<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">Form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">hidden</span> /&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>Yes<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-name">Form</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span></span>
    );
}</code></pre><p>不仅没有 useState 数量爆炸，也不需要手工维护 dialog 状态。</p><p>其他优点：</p><ol><li>更合理的拆分业务逻辑，disable UI 和 API 和 member detail 完全隔离，更容易测试。</li><li>更容易处理 page 状态。例如多个表单的提交状态，以前常常会出现 form1.submitting || form2.submitting 的问题，现在只需要进行页面跳转即可。</li><li>更容易处理多级弹窗。只需要简单重复 Outlet 即可，避免了多层嵌套。</li></ol><p>缺点：</p><ul><li>框架依赖。这是 Remix Nested Routes 前提下的实现方案，不是 Web Standards。</li></ul><p>背景资料：</p><ul><li><a class="tc-tiddlylink-external" href="https://www.jqueryscript.net/demo/Simple-jQuery-Modal-Dialog-Box-Plugin-Dialog/" rel="noopener noreferrer" target="_blank">https://www.jqueryscript.net/demo/Simple-jQuery-Modal-Dialog-Box-Plugin-Dialog/</a></li><li><a class="tc-tiddlylink-external" href="https://sweetalert2.github.io/" rel="noopener noreferrer" target="_blank">https://sweetalert2.github.io/</a></li><li><a class="tc-tiddlylink-external" href="https://www.radix-ui.com/primitives/docs/components/alert-dialog" rel="noopener noreferrer" target="_blank">https://www.radix-ui.com/primitives/docs/components/alert-dialog</a></li><li><a class="tc-tiddlylink-external" href="https://daisyui.com/components/modal/" rel="noopener noreferrer" target="_blank">https://daisyui.com/components/modal/</a></li><li><a class="tc-tiddlylink-external" href="https://remix.run/docs/en/main/file-conventions/routes#nested-routes" rel="noopener noreferrer" target="_blank">https://remix.run/docs/en/main/file-conventions/routes#nested-routes</a></li></ul>
          </div>          
      </div>
  </div>
</div>     


<div class="copyright">
<strong>
<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">
版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
</a>
</strong>
</div>

<style>
.copyright {
  padding: 0.5rem 1rem;
  text-align: center;
}

.copyright:hover {
  opacity: 0.9;
}
</style>


]]></description>
      <pubDate>Thu, 11 April 2024 10:6:24 -00:00</pubDate>
			<guid>https://thaddeusjiang.com/2024-04-11-remix-gai-bian-liao-wo-bian-xie-dialog-de-fang-shi</guid>      
   </item>

   <item>
      <title>2024-03-12 JS REPL become useful</title>
      <link>https://thaddeusjiang.com/2024-03-12-js-repl-become-useful</link>
			<description><![CDATA[
<div class="container">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2 my-4"><nav aria-label="main navigation" class="navbar" role="navigation"><p><div class="navbar-brand">
          <a href="./">
              <h1 class="title">Thaddeus Jiang</h1>
              <p class="subtitle">I know I don't know, stay curious.</p>
          </a>
      </div></p><p><div class="navbar-end mt-2 subtitle is-5"><a class="tc-tiddlylink tc-tiddlylink-shadow tc-tiddlylink-resolves" href="./#blog">Posts</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/wiki" rel="noopener noreferrer" target="_blank">Wiki</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/rss.xml" rel="noopener noreferrer" target="_blank">RSS</a> </div></p></nav></div>
</div>


<div class="container mt-4">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2">
      <div>
          <div class="block content blog">
            <h1 class="subtitle">2024-03-12 JS REPL become useful</h1>
            <hr>

            <p>一直以来我一直在寻找一个 JS 工具，可以让我不退出 console (REPL) 就直接安装新的依赖。Thanks God. 我终于找到了。🥳</p><p><code>bun repl</code> is so cool. </p><p>Demo: </p><pre class="hljs"><code class="sh hljs">bun repl

&gt; import dayjs from <span class="hljs-string">&quot;dayjs&quot;</span>
&gt; dayjs().toISOString()
<span class="hljs-string">&#x27;2024-03-12T01:41:09.763Z&#x27;</span></code></pre><h2 class="">Why I want to install dependencies in console?</h2><p>很多时候我只是想运行某个函数，而不是写代码。在 bun repl 之前我一直使用 RunKit.com 做这件事。但是 RunKit 有一个很重要的不足，就是不支持 ESM ，因为我日常工作已经全面切换到 ESM，每次在 RunKit 中写 require("somelib") 让我觉得十分割裂。</p><p>或许对于很多人来说，npm i -y ，然后 npm install dayjs 也是一个不错的选择。但是我个人不喜欢在 local 留下太多临时代码，并且 node_modules 真的太占存储空间了。我还是喜欢在 console 中“用完即弃”。</p><h2 class="">Where I learn this Tips?</h2><p>1. Elixir iex shell 提供这个功能</p><pre><code>iex

iex&gt; Mix.install(  [{:timex, "~&gt; 3.0"}])
iex&gt; Timex.now
~U[2024-03-12 01:57:40.350390Z]</code></pre><p>作为一个老派程序员，我真的无法使用没有 REPL 的编程语言。REPL 不好用的话和没有没有区别，node 直接开启的那个运行环境根本就不算一个合格的 REPL。</p><pre class="hljs"><code class="sh hljs">node        
Welcome to Node.js v18.14.0.
Type <span class="hljs-string">&quot;.help&quot;</span> <span class="hljs-keyword">for</span> more information.
&gt; npm install dayjs
npm should be run outside of the Node.js REPL, <span class="hljs-keyword">in</span> your normal shell.
(Press Ctrl+D to <span class="hljs-built_in">exit</span>.)
&gt; 
&gt; import dayjs from <span class="hljs-string">&quot;dayjs&quot;</span>
import dayjs from <span class="hljs-string">&quot;dayjs&quot;</span>
^^^^^^

Uncaught:
SyntaxError: Cannot use import statement inside the Node.js REPL, alternatively use dynamic import</code></pre><p>refs:</p><ul><li><a class="tc-tiddlylink-external" href="https://github.com/jhmaster2000/bun-repl" rel="noopener noreferrer" target="_blank">https://github.com/jhmaster2000/bun-repl</a></li></ul>
          </div>          
      </div>
  </div>
</div>     


<div class="copyright">
<strong>
<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">
版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
</a>
</strong>
</div>

<style>
.copyright {
  padding: 0.5rem 1rem;
  text-align: center;
}

.copyright:hover {
  opacity: 0.9;
}
</style>


]]></description>
      <pubDate>Tue, 12 March 2024 2:3:55 -00:00</pubDate>
			<guid>https://thaddeusjiang.com/2024-03-12-js-repl-become-useful</guid>      
   </item>

   <item>
      <title>2024-03-09 第 n 次复习 GenServer</title>
      <link>https://thaddeusjiang.com/2024-03-09-di-n-ci-fu-xi-genserver</link>
			<description><![CDATA[
<div class="container">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2 my-4"><nav aria-label="main navigation" class="navbar" role="navigation"><p><div class="navbar-brand">
          <a href="./">
              <h1 class="title">Thaddeus Jiang</h1>
              <p class="subtitle">I know I don't know, stay curious.</p>
          </a>
      </div></p><p><div class="navbar-end mt-2 subtitle is-5"><a class="tc-tiddlylink tc-tiddlylink-shadow tc-tiddlylink-resolves" href="./#blog">Posts</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/wiki" rel="noopener noreferrer" target="_blank">Wiki</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/rss.xml" rel="noopener noreferrer" target="_blank">RSS</a> </div></p></nav></div>
</div>


<div class="container mt-4">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2">
      <div>
          <div class="block content blog">
            <h1 class="subtitle">2024-03-09 第 n 次复习 GenServer</h1>
            <hr>

            <p>这是我第 n 次复习 GenServer，一直很喜欢 Elixir &amp; Erlang，希望今后可以用 Elixir &amp; Erlang 作为主力编程语言，希望它们能让我今后的程序员生涯变得快乐且有趣。</p><p>Dave Thomas 的书真的太棒了，每次读都有新感受，感受到 Dave 在编程领域的深思熟虑和远见卓识。</p><h2 class="">复习</h2><p>复习一下 GenServer 的概念和特点，帮助自己不断重复记忆，直到内化到肌肉，内化成像开车一样的技能。</p><p>关键词：<code>OTP</code> <code>applications</code> <code>processes</code> <code>behavior</code> <code>callback</code> <code>state-machine</code> <code>GenServer</code></p><p>GenServer 是 OTP 的概念，OTP 是 Erlang 社区开发复杂项目的架构和工具。OTP 可以让我们专注业务，不用每次都从头搭建手脚架，尤其是复杂业务的架构，例如：error handling、application communication、hot code swapping 等等。</p><p>memo: Elixir &amp; Erlang 社区中 applications 不一定是其他社区中定义的那种应用，可能仅仅是一个多个 processes。Elixir &amp; Erlang application 实现了 behavior，behavior 提供一些 callbacks finite-state machines 帮助我们更好的架构复杂应用。</p><h2 class="">Elixir GenServer 风格</h2><p>Elixir GenServer 推荐的代码风格不同于其他编程语言的代码风格。</p><blockquote class="tc-quote tc-big-quote"><p>GenServer 推荐我们把 External API 和 GenServer implementations 放在同一个 module 内。Elixir 提供的 <code>__MODOULE__</code> 让这种风格实现起来非常简单。
</p></blockquote><p>形如：</p><pre><code>defmodule Stack do
  use GenServer

  # Client

  def start_link(default) when is_list(default) do
    GenServer.start_link(__MODULE__, default)
  end

  def push(pid, element) do
    GenServer.cast(pid, {:push, element})
  end

  def pop(pid) do
    GenServer.call(pid, :pop)
  end

  # Server (callbacks)

  @impl true
  def init(stack) do
    {:ok, stack}
  end

  @impl true
  def handle_call(:pop, _from, [head | tail]) do
    {:reply, head, tail}
  end

  @impl true
  def handle_cast({:push, element}, state) do
    {:noreply, [element | state]}
  end
end</code></pre><pre><code># Usage
{:ok, pid} = Stack.start_link([:hello, :world])
Stack.pop(pid)
:hello

Stack.pop(pid)
:world

Stack.push(pid, :nice_job)
:nice_job</code></pre><p>我喜欢这种风格，对于我来说在同个一个 module（file）中实现 API 和 callback 很容易理解，且容易维护。同理，我也喜欢 <a class="tc-tiddlylink-external" href="https://remix.run" rel="noopener noreferrer" target="_blank">https://remix.run</a> 设计的 loader action 风格。</p><p>我不喜欢 Java 推荐的定义和实现分离的风格，很鸡肋，很枯燥。借用 Dave Thomas 的一句话：</p><blockquote class="tc-quote tc-big-quote"><p>It isn't difficult, but it is tedious.
</p><cite>Dave Thomas</cite></blockquote><p>不符合 Elixir GenServer 风格的实现：<a class="tc-tiddlylink-external" href="https://github.com/ThaddeusJiang/elixir_playground/tree/main/gen_server/not_elixir_style_gen_server" rel="noopener noreferrer" target="_blank">https://github.com/ThaddeusJiang/elixir_playground/tree/main/gen_server/not_elixir_style_gen_server</a></p><p>今天是 2024-03-09 （周六）天气晴朗，不用工作的日子真舒服啊。</p>
          </div>          
      </div>
  </div>
</div>     


<div class="copyright">
<strong>
<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">
版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
</a>
</strong>
</div>

<style>
.copyright {
  padding: 0.5rem 1rem;
  text-align: center;
}

.copyright:hover {
  opacity: 0.9;
}
</style>


]]></description>
      <pubDate>Sat, 9 March 2024 9:20:27 -00:00</pubDate>
			<guid>https://thaddeusjiang.com/2024-03-09-di-n-ci-fu-xi-genserver</guid>      
   </item>

</channel>
</rss>
