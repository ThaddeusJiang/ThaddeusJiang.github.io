<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   <title>Thaddeus Jiang</title>
   <link>https://thaddeusjiang.com</link>
   <description>I know I don't know, stay curious.</description>
   <item>
      <title>2024-03-12 JS REPL become useful</title>
      <link>https://thaddeusjiang.com/2024-03-12-js-repl-become-useful</link>
			<description><![CDATA[
<div class="container">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2 my-4"><nav aria-label="main navigation" class="navbar" role="navigation"><p><div class="navbar-brand">
          <a href="./">
              <h1 class="title">Thaddeus Jiang</h1>
              <p class="subtitle">I know I don't know, stay curious.</p>
          </a>
      </div></p><p><div class="navbar-end mt-2 subtitle is-5"><a class="tc-tiddlylink tc-tiddlylink-shadow tc-tiddlylink-resolves" href="./#blog">Posts</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/wiki" rel="noopener noreferrer" target="_blank">Wiki</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/rss.xml" rel="noopener noreferrer" target="_blank">RSS</a> </div></p></nav></div>
</div>


<div class="container mt-4">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2">
      <div>
          <div class="block content blog">
            <h1 class="subtitle">2024-03-12 JS REPL become useful</h1>
            <hr>

            <p>一直以来我一直在寻找一个 JS 工具，可以让我不退出 console (REPL) 就直接安装新的依赖。Thanks God. 我终于找到了。🥳</p><p><code>bun repl</code> is so cool. </p><p>Demo: </p><pre class="hljs"><code class="sh hljs">bun repl

&gt; import dayjs from <span class="hljs-string">&quot;dayjs&quot;</span>
&gt; dayjs().toISOString()
<span class="hljs-string">&#x27;2024-03-12T01:41:09.763Z&#x27;</span></code></pre><h2 class="">Why I want to install dependencies in console?</h2><p>很多时候我只是想运行某个函数，而不是写代码。在 bun repl 之前我一直使用 RunKit.com 做这件事。但是 RunKit 有一个很重要的不足，就是不支持 ESM ，因为我日常工作已经全面切换到 ESM，每次在 RunKit 中写 require("somelib") 让我觉得十分割裂。</p><p>或许对于很多人来说，npm i -y ，然后 npm install dayjs 也是一个不错的选择。但是我个人不喜欢在 local 留下太多临时代码，并且 node_modules 真的太占存储空间了。我还是喜欢在 console 中“用完即弃”。</p><h2 class="">Where I learn this Tips?</h2><p>1. Elixir iex shell 提供这个功能</p><pre><code>iex

iex&gt; Mix.install(  [{:timex, "~&gt; 3.0"}])
iex&gt; Timex.now
~U[2024-03-12 01:57:40.350390Z]</code></pre><p>作为一个老派程序员，我真的无法使用没有 REPL 的编程语言。REPL 不好用的话和没有没有区别，node 直接开启的那个运行环境根本就不算一个合格的 REPL。</p><pre class="hljs"><code class="sh hljs">node        
Welcome to Node.js v18.14.0.
Type <span class="hljs-string">&quot;.help&quot;</span> <span class="hljs-keyword">for</span> more information.
&gt; npm install dayjs
npm should be run outside of the Node.js REPL, <span class="hljs-keyword">in</span> your normal shell.
(Press Ctrl+D to <span class="hljs-built_in">exit</span>.)
&gt; 
&gt; import dayjs from <span class="hljs-string">&quot;dayjs&quot;</span>
import dayjs from <span class="hljs-string">&quot;dayjs&quot;</span>
^^^^^^

Uncaught:
SyntaxError: Cannot use import statement inside the Node.js REPL, alternatively use dynamic import</code></pre><p>refs:</p><ul><li><a class="tc-tiddlylink-external" href="https://github.com/jhmaster2000/bun-repl" rel="noopener noreferrer" target="_blank">https://github.com/jhmaster2000/bun-repl</a></li></ul>
          </div>          
      </div>
  </div>
</div>     


<div class="copyright">
<strong>
<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">
版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
</a>
</strong>
</div>

<style>
.copyright {
  padding: 0.5rem 1rem;
  text-align: center;
}

.copyright:hover {
  opacity: 0.9;
}
</style>


]]></description>
      <pubDate>Tue, 12 March 2024 2:3:55 -00:00</pubDate>
			<guid>https://thaddeusjiang.com/2024-03-12-js-repl-become-useful</guid>      
   </item>

   <item>
      <title>2024-03-09 第 n 次复习 GenServer</title>
      <link>https://thaddeusjiang.com/2024-03-09-di-n-ci-fu-xi-genserver</link>
			<description><![CDATA[
<div class="container">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2 my-4"><nav aria-label="main navigation" class="navbar" role="navigation"><p><div class="navbar-brand">
          <a href="./">
              <h1 class="title">Thaddeus Jiang</h1>
              <p class="subtitle">I know I don't know, stay curious.</p>
          </a>
      </div></p><p><div class="navbar-end mt-2 subtitle is-5"><a class="tc-tiddlylink tc-tiddlylink-shadow tc-tiddlylink-resolves" href="./#blog">Posts</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/wiki" rel="noopener noreferrer" target="_blank">Wiki</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/rss.xml" rel="noopener noreferrer" target="_blank">RSS</a> </div></p></nav></div>
</div>


<div class="container mt-4">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2">
      <div>
          <div class="block content blog">
            <h1 class="subtitle">2024-03-09 第 n 次复习 GenServer</h1>
            <hr>

            <p>这是我第 n 次复习 GenServer，一直很喜欢 Elixir &amp; Erlang，希望今后可以用 Elixir &amp; Erlang 作为主力编程语言，希望它们能让我今后的程序员生涯变得快乐且有趣。</p><p>Dave Thomas 的书真的太棒了，每次读都有新感受，感受到 Dave 在编程领域的深思熟虑和远见卓识。</p><h2 class="">复习</h2><p>复习一下 GenServer 的概念和特点，帮助自己不断重复记忆，直到内化到肌肉，内化成像开车一样的技能。</p><p>关键词：<code>OTP</code> <code>applications</code> <code>processes</code> <code>behavior</code> <code>callback</code> <code>state-machine</code> <code>GenServer</code></p><p>GenServer 是 OTP 的概念，OTP 是 Erlang 社区开发复杂项目的架构和工具。OTP 可以让我们专注业务，不用每次都从头搭建手脚架，尤其是复杂业务的架构，例如：error handling、application communication、hot code swapping 等等。</p><p>memo: Elixir &amp; Erlang 社区中 applications 不一定是其他社区中定义的那种应用，可能仅仅是一个多个 processes。Elixir &amp; Erlang application 实现了 behavior，behavior 提供一些 callbacks finite-state machines 帮助我们更好的架构复杂应用。</p><h2 class="">Elixir GenServer 风格</h2><p>Elixir GenServer 推荐的代码风格不同于其他编程语言的代码风格。</p><blockquote class="tc-quote tc-big-quote"><p>GenServer 推荐我们把 External API 和 GenServer implementations 放在同一个 module 内。Elixir 提供的 <code>__MODOULE__</code> 让这种风格实现起来非常简单。
</p></blockquote><p>形如：</p><pre><code>defmodule Stack do
  use GenServer

  # Client

  def start_link(default) when is_list(default) do
    GenServer.start_link(__MODULE__, default)
  end

  def push(pid, element) do
    GenServer.cast(pid, {:push, element})
  end

  def pop(pid) do
    GenServer.call(pid, :pop)
  end

  # Server (callbacks)

  @impl true
  def init(stack) do
    {:ok, stack}
  end

  @impl true
  def handle_call(:pop, _from, [head | tail]) do
    {:reply, head, tail}
  end

  @impl true
  def handle_cast({:push, element}, state) do
    {:noreply, [element | state]}
  end
end</code></pre><pre><code># Usage
{:ok, pid} = Stack.start_link([:hello, :world])
Stack.pop(pid)
:hello

Stack.pop(pid)
:world

Stack.push(pid, :nice_job)
:nice_job</code></pre><p>我喜欢这种风格，对于我来说在同个一个 module（file）中实现 API 和 callback 很容易理解，且容易维护。同理，我也喜欢 <a class="tc-tiddlylink-external" href="https://remix.run" rel="noopener noreferrer" target="_blank">https://remix.run</a> 设计的 loader action 风格。</p><p>我不喜欢 Java 推荐的定义和实现分离的风格，很鸡肋，很枯燥。借用 Dave Thomas 的一句话：</p><blockquote class="tc-quote tc-big-quote"><p>It isn't difficult, but it is tedious.
</p><cite>Dave Thomas</cite></blockquote><p>不符合 Elixir GenServer 风格的实现：<a class="tc-tiddlylink-external" href="https://github.com/ThaddeusJiang/elixir_playground/tree/main/gen_server/not_elixir_style_gen_server" rel="noopener noreferrer" target="_blank">https://github.com/ThaddeusJiang/elixir_playground/tree/main/gen_server/not_elixir_style_gen_server</a></p><p>今天是 2024-03-09 （周六）天气晴朗，不用工作的日子真舒服啊。</p>
          </div>          
      </div>
  </div>
</div>     


<div class="copyright">
<strong>
<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">
版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
</a>
</strong>
</div>

<style>
.copyright {
  padding: 0.5rem 1rem;
  text-align: center;
}

.copyright:hover {
  opacity: 0.9;
}
</style>


]]></description>
      <pubDate>Sat, 9 March 2024 9:20:27 -00:00</pubDate>
			<guid>https://thaddeusjiang.com/2024-03-09-di-n-ci-fu-xi-genserver</guid>      
   </item>

   <item>
      <title>2024-03-07 Don't review Prisma Migration generated SQL</title>
      <link>https://thaddeusjiang.com/2024-03-07-don-t-review-prisma-migration-generated-sql</link>
			<description><![CDATA[
<div class="container">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2 my-4"><nav aria-label="main navigation" class="navbar" role="navigation"><p><div class="navbar-brand">
          <a href="./">
              <h1 class="title">Thaddeus Jiang</h1>
              <p class="subtitle">I know I don't know, stay curious.</p>
          </a>
      </div></p><p><div class="navbar-end mt-2 subtitle is-5"><a class="tc-tiddlylink tc-tiddlylink-shadow tc-tiddlylink-resolves" href="./#blog">Posts</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/wiki" rel="noopener noreferrer" target="_blank">Wiki</a> | <a class="tc-tiddlylink-external" href="https://thaddeusjiang.com/rss.xml" rel="noopener noreferrer" target="_blank">RSS</a> </div></p></nav></div>
</div>


<div class="container mt-4">
  <div class="column is-6-desktop is-offset-3-desktop is-8 is-offset-2">
      <div>
          <div class="block content blog">
            <h1 class="subtitle">2024-03-07 Don't review Prisma Migration generated SQL</h1>
            <hr>

            <p>因为大量熟练使用 database tools，如：Prisma 和 Ecto，我已经不能熟练写出相对复杂 SQL 了。😭</p><p>目前，我在设计和开发一个能源回收和调度系统，因为我是一个以“懒”作为美德的程序员，我想直接使用 Supabase 提供的 Auth 服务。</p><p>但是我发现在 Prisma schema 中实现的 many-to-many 关系，无法优雅地使用 supabase-js 查询。</p><p>于是我研究了一下原因，不看不知道，一看吓一跳。Prisma Migration 生成的 many-to-many SQL 好复杂，完全违反直觉，反正我 review 困难。</p><p>下面是一个 role:permission many-to-many 的例子：</p><pre class="hljs"><code class="sql hljs"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> prisma.schema
model Permission {
  id    <span class="hljs-type">Int</span>    <span class="hljs-variable">@id</span> <span class="hljs-variable">@default</span>(autoincrement())
  roles Role[]
}

model Role {
  id          <span class="hljs-type">Int</span>          <span class="hljs-variable">@id</span> <span class="hljs-variable">@default</span>(autoincrement())
  permissions Permission[]
}</code></pre><p>The SQL was generated by Prisma Migration:</p><pre class="hljs"><code class="sql hljs"><span class="hljs-comment">-- CreateTable</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> &quot;_PermissionToRole&quot; (
    &quot;A&quot; <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    &quot;B&quot; <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>
);

<span class="hljs-comment">-- CreateIndex</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX &quot;_PermissionToRole_AB_unique&quot; <span class="hljs-keyword">ON</span> &quot;_PermissionToRole&quot;(&quot;A&quot;, &quot;B&quot;);

<span class="hljs-comment">-- CreateIndex</span>
<span class="hljs-keyword">CREATE</span> INDEX &quot;_PermissionToRole_B_index&quot; <span class="hljs-keyword">ON</span> &quot;_PermissionToRole&quot;(&quot;B&quot;);

<span class="hljs-comment">-- AddForeignKey</span>
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> &quot;_PermissionToRole&quot; <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> &quot;_PermissionToRole_A_fkey&quot; <span class="hljs-keyword">FOREIGN</span> KEY (&quot;A&quot;) <span class="hljs-keyword">REFERENCES</span> &quot;Permission&quot;(&quot;id&quot;) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE;

<span class="hljs-comment">-- AddForeignKey</span>
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> &quot;_PermissionToRole&quot; <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> &quot;_PermissionToRole_B_fkey&quot; <span class="hljs-keyword">FOREIGN</span> KEY (&quot;B&quot;) <span class="hljs-keyword">REFERENCES</span> &quot;Role&quot;(&quot;id&quot;) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE;</code></pre><p>上面 SQL 看的我一愣一愣的。而且上面 SQL 生成的关系在 supabase-js 查询语句很丑。</p><pre class="hljs"><code class="js hljs"><span class="hljs-keyword">const</span> { data, error } = <span class="hljs-keyword">await</span> supabase.<span class="hljs-title function_">from</span>(<span class="hljs-string">&quot;Role&quot;</span>).<span class="hljs-title function_">select</span>(<span class="hljs-string">`*, _PermissionToRole(
  A: Permission (*)
)`</span>);</code></pre><p>于是我凭着记忆手写了下面这段 SQL。</p><pre class="hljs"><code class="sql hljs"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> role (
  &quot;id&quot; serial <span class="hljs-keyword">primary</span> key,
);

<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> permission (
  &quot;id&quot; serial <span class="hljs-keyword">primary</span> key,
);

<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> members (
  &quot;role_id&quot; <span class="hljs-type">int</span> <span class="hljs-keyword">references</span> role,
  &quot;permission_id&quot; <span class="hljs-type">int</span> <span class="hljs-keyword">references</span> permission,
  <span class="hljs-keyword">primary</span> key (role_id, permission_id)
);</code></pre><p>经过测试，我手写的 SQL 可以使用 supabase-js 进行关联查询，代码如下：</p><pre class="hljs"><code class="diff hljs"><span class="hljs-deletion">- const { data, error } = await supabase.from(&quot;Role&quot;).select(`*, _PermissionToRole(</span>
<span class="hljs-deletion">-   A: Permission (*)</span>
<span class="hljs-deletion">- )`);</span>

<span class="hljs-addition">+ const {data, error} = await supabase.from(&quot;role&quot;).select(&quot;*, permission(*)&quot;)</span></code></pre><h2 class="">那么，今后我会手写 SQL 管理 migrations 吗？</h2><p>答：不会，如果是团队合作的 JS 项目，我依然会使用 Prisma Migration，因为复杂的关系和限制手写 SQL 成本太高了。工作量、易出错、缺少检查工具。</p><p>所以，由于种种原因，我的结论：</p><blockquote class="tc-quote tc-big-quote"><p>Don't review Prisma Migration generated SQL, focus on prisam.schema.
</p><cite>TJ 2024-03-07</cite></blockquote><h2 class="">如果是非团队项目 or 非 JS 项目</h2><p>我会使用 Ecto 管理 migrations。</p><p>Ecto 生成的 many-to-many SQL 简洁又准确</p><pre><code>create table(:role_permission, primary_key: false) do
  add :role_id, references(:role), primary_key: true
  add :permission_id, references(:permission), primary_key: true
end</code></pre><pre class="hljs"><code class="sql hljs"><span class="hljs-comment">-- Table Definition</span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> &quot;public&quot;.&quot;role_permission&quot; (
    &quot;role_id&quot; int8 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    &quot;permission_id&quot; int8 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    <span class="hljs-keyword">CONSTRAINT</span> &quot;role_permission_role_id_fkey&quot; <span class="hljs-keyword">FOREIGN</span> KEY (&quot;role_id&quot;) <span class="hljs-keyword">REFERENCES</span> &quot;public&quot;.&quot;role&quot;(&quot;id&quot;),
    <span class="hljs-keyword">CONSTRAINT</span> &quot;role_permission_permission_id_fkey&quot; <span class="hljs-keyword">FOREIGN</span> KEY (&quot;permission_id&quot;) <span class="hljs-keyword">REFERENCES</span> &quot;public&quot;.&quot;permission&quot;(&quot;id&quot;),
    <span class="hljs-keyword">PRIMARY</span> KEY (&quot;role_id&quot;,&quot;permission_id&quot;)
);</code></pre><p>对比 Prsima 生成的 SQL，高下立判。
</p>
          </div>          
      </div>
  </div>
</div>     


<div class="copyright">
<strong>
<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">
版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）
</a>
</strong>
</div>

<style>
.copyright {
  padding: 0.5rem 1rem;
  text-align: center;
}

.copyright:hover {
  opacity: 0.9;
}
</style>


]]></description>
      <pubDate>Thu, 7 March 2024 11:2:45 -00:00</pubDate>
			<guid>https://thaddeusjiang.com/2024-03-07-don-t-review-prisma-migration-generated-sql</guid>      
   </item>

</channel>
</rss>
